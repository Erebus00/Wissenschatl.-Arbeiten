\chapter{Komplexität}

Wir wollen hier die Zeitkomplexität zum Durchlaufen und Finden eines bestimmten Datenelementes in einem B Baumes untersuchen. Diese gibt an, wovon der Zeitaufwand abhängt, um den B Baum nach einem Datenelement zu durchsuchen. Sowohl die der Zeitaufwand der  Operationen  Finden, Einfügen und Löschen hängen auch direkt von diesem Zeitaufwand ab.  So wie logischerweise  zum Löschen eines Datenelementes dieses vor der eigentlichen Operation zuerst gefunden werden muss, muss auch vor dem Einfügen zuerst festgestellt werden an welche Stelle das neue Element eingefügt werden muss, damit die Ordnung der Datenelemente immer noch gewährleistet ist. Diese Ortung der Einfügstelle kommt einem Finden (zum Beispiel des Nachbarelementes) gleich.
Bei der exakten Betrachtung von Laufzeiten, müssten viele verschiedene Fälle unterschieden werden, so wird sich oft darauf beschränkt die Komplexitätsklasse des Laufzeitverhaltens zu bestimmen, d. h. es wird bestimmt welcher Klasse von Funktionen die Laufzeitfunktion gehört (linear, quadratisch, logarithmisch...). Die sogenannte Komplexitätsklasse ist im Vergleich zur genauen Laufzeitfunktion einfacher zu bestimmen. Zwar ist eine genaue Berechnung der eigentlichen Laufzeit nicht möglich, aber es ist möglich eine asymptotische Obergrenze der Laufzeit und einen Vergleich zwischen verschiedenen Strukturen und Algorithmen zu erstellen. 


\section{Komplexitätsklasse beim B-Baum}

Zunächst müssen wir uns mit der Struktur des B Baumes befassen, um eine Komplexitätsklasse der Operationen auf den B Baum bestimmen zu können. Hierzu zuerst einige Definitionen und Notationen:
Man nennt Tiefe t, den Abstand eines beliebigen Knotens zur Wurzel.
Man nennt Höhe h eines B Baumes den Abstand von der Wurzel zu den Blättern, es ist also die Tiefe t der Blätter.
Die Wurzel ist der Vorfahre jedes Knotens.
Ein Blatt ist ein Feld mit Datenelementen und befindet sich am ?Ende? des Baumes, d. H. ein Blatt hat keine Nachkommen (Söhne). 
Eine spezielle Eigenschaft des B Baumes ist es, dass alle Blätter die gleiche Tiefe T besitzen und stellen somit die Höhe h des B Baumes dar.
Um ein Datenelement zu finden, das sich gezwungenerweise in den Blättern befindet, muss ein Algorithmus die Datenstruktur von der Wurzel bis zu dem gesuchten Blatt durchlaufen, also die Höhe h durchlaufen. Auf dem Weg von einem Knoten zum anderen, muss es einen Speicherzugriff geben, die Anzahl der Speicherzugriffe von der Wurzel zum Blatt ist immer gleich der Höhe h. Folglich ist die Komplexität der meisten Operationen (Find, Insert , Delete) auf B Bäumen proportional zur Höhe h des B Baumes.

Wir wollen nun die Höhe h des B Baumes in Zusammenhang mit der gesamten Anzahl \# von Datenelementen im B Baum bringen. Dazu müssen wir entscheiden wie viele Kinder jeder Knoten haben soll, sei 2n diese maximale Anzahl der Kinder. Je nach dem Füllgrad der Knoten, der bei einem B Baum für jeden Knoten zwischen mindestens n und maximal 2n liegt, ergeben sich verschiedene Höhen für die gleiche Anzahl von Datenelementen ?. Die grö\ss te Höhe h, d.h. die längste Laufzeit, weist ein B Baum auf, falls jeder Knoten nur die Hälfte der möglichen Kinder aufweist. Dagegen hat ein B Baum mit ? Datenelementen die kürzeste Höhe h, und somit auch die kürzeste Laufzeit, falls jeder Knoten die maximal mögliche Anzahl von Kindern d. h. 2n aufweist. Daher ergeben sich folgende Grenzwerte für h :
\\[0.5in]
{\large \centerline {$\log_2n+1 {(\#+1)-1} \leq h \leq  \log_n+1 {(\frac{\#+1}{2})}$} }

